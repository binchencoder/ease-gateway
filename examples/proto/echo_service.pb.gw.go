// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: examples/proto/echo_service.proto

/*
Package proto is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package proto

import (
	"context"
	"io"
	"net/http"
	"regexp"
	"strings"
	"sync"
	"unicode/utf8"

	"binchencoder.com/ease-gateway/gateway/runtime"
	vexpb "binchencoder.com/gateway-proto/data"
	fpb "binchencoder.com/gateway-proto/frontend"
	lgr "binchencoder.com/letsgo/grpc"
	"binchencoder.com/skylb-api/balancer"
	"binchencoder.com/skylb-api/client"
	"binchencoder.com/skylb-api/client/option"
	skypb "binchencoder.com/skylb-api/proto"
	"github.com/golang/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/utilities"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/naming"
	"google.golang.org/grpc/status"
)

var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ sync.RWMutex
var _ proto.Message
var _ context.Context
var _ grpc.ClientConn
var _ client.ServiceCli
var _ vexpb.ServiceId
var _ = http.MethodGet
var _ regexp.Regexp
var _ = balancer.ConsistentHashing
var _ option.BalancerCreator
var _ naming.Resolver
var _ strings.Reader
var _ = utf8.UTFMax

// TODO (jiezmo): check if there is any rule before create this var.
var examples_proto_echo_service_error = lgr.ToGrpcError(codes.InvalidArgument, &fpb.Error{Code: fpb.ErrorCode_BADPARAM_ERROR, Params: []string{"Validation error"}})

// Validation methods start

// Validation methods done

var (
	filter_EchoService_Echo_0 = &utilities.DoubleArray{Encoding: map[string]int{"id": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

func request_EchoService_Echo_0(ctx context.Context, marshaler runtime.Marshaler, client EchoServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq SimpleMessage
	var metadata runtime.ServerMetadata
	spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["id"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
	}

	protoReq.Id, err = runtime.String(val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_EchoService_Echo_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	// Only hook up for non-stream call for now.

	runtime.RequestParsed(ctx, spec, "EchoService", "Echo", &protoReq, &metadata)
	ctx = runtime.PreLoadBalance(ctx, "ROUND_ROBIN", "", &protoReq)
	msg, err := client.Echo(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	runtime.RequestHandled(ctx, spec, "EchoService", "Echo", msg, &metadata, err)
	return msg, metadata, err

}

var (
	filter_EchoService_Echo_1 = &utilities.DoubleArray{Encoding: map[string]int{"id": 0, "num": 1}, Base: []int{1, 1, 2, 0, 0}, Check: []int{0, 1, 1, 2, 3}}
)

func request_EchoService_Echo_1(ctx context.Context, marshaler runtime.Marshaler, client EchoServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq SimpleMessage
	var metadata runtime.ServerMetadata
	spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["id"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
	}

	protoReq.Id, err = runtime.String(val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
	}

	val, ok = pathParams["num"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "num")
	}

	protoReq.Num, err = runtime.Int64(val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "num", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_EchoService_Echo_1); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	// Only hook up for non-stream call for now.

	runtime.RequestParsed(ctx, spec, "EchoService", "Echo", &protoReq, &metadata)
	ctx = runtime.PreLoadBalance(ctx, "ROUND_ROBIN", "", &protoReq)
	msg, err := client.Echo(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	runtime.RequestHandled(ctx, spec, "EchoService", "Echo", msg, &metadata, err)
	return msg, metadata, err

}

var (
	filter_EchoService_Echo_2 = &utilities.DoubleArray{Encoding: map[string]int{"id": 0, "num": 1, "lang": 2}, Base: []int{1, 1, 2, 3, 0, 0, 0}, Check: []int{0, 1, 1, 1, 2, 3, 4}}
)

func request_EchoService_Echo_2(ctx context.Context, marshaler runtime.Marshaler, client EchoServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq SimpleMessage
	var metadata runtime.ServerMetadata
	spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["id"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
	}

	protoReq.Id, err = runtime.String(val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
	}

	val, ok = pathParams["num"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "num")
	}

	protoReq.Num, err = runtime.Int64(val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "num", err)
	}

	val, ok = pathParams["lang"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "lang")
	}

	if protoReq.Code == nil {
		protoReq.Code = &SimpleMessage_Lang{}
	} else if _, ok := protoReq.Code.(*SimpleMessage_Lang); !ok {
		return nil, metadata, grpc.Errorf(codes.InvalidArgument, "expect type: *SimpleMessage_Lang, but: %t\n", protoReq.Code)
	}
	protoReq.Code.(*SimpleMessage_Lang).Lang, err = runtime.String(val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "lang", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_EchoService_Echo_2); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	// Only hook up for non-stream call for now.

	runtime.RequestParsed(ctx, spec, "EchoService", "Echo", &protoReq, &metadata)
	ctx = runtime.PreLoadBalance(ctx, "ROUND_ROBIN", "", &protoReq)
	msg, err := client.Echo(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	runtime.RequestHandled(ctx, spec, "EchoService", "Echo", msg, &metadata, err)
	return msg, metadata, err

}

var (
	filter_EchoService_Echo_3 = &utilities.DoubleArray{Encoding: map[string]int{"id": 0, "line_num": 1, "status": 2, "note": 3}, Base: []int{1, 1, 2, 1, 3, 0, 0, 0}, Check: []int{0, 1, 1, 1, 4, 2, 3, 5}}
)

func request_EchoService_Echo_3(ctx context.Context, marshaler runtime.Marshaler, client EchoServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq SimpleMessage
	var metadata runtime.ServerMetadata
	spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["id"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "id")
	}

	protoReq.Id, err = runtime.String(val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "id", err)
	}

	val, ok = pathParams["line_num"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "line_num")
	}

	if protoReq.Code == nil {
		protoReq.Code = &SimpleMessage_LineNum{}
	} else if _, ok := protoReq.Code.(*SimpleMessage_LineNum); !ok {
		return nil, metadata, grpc.Errorf(codes.InvalidArgument, "expect type: *SimpleMessage_LineNum, but: %t\n", protoReq.Code)
	}
	protoReq.Code.(*SimpleMessage_LineNum).LineNum, err = runtime.Int64(val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "line_num", err)
	}

	val, ok = pathParams["status.note"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "status.note")
	}

	err = runtime.PopulateFieldFromPath(&protoReq, "status.note", val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "status.note", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_EchoService_Echo_3); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	// Only hook up for non-stream call for now.

	runtime.RequestParsed(ctx, spec, "EchoService", "Echo", &protoReq, &metadata)
	ctx = runtime.PreLoadBalance(ctx, "ROUND_ROBIN", "", &protoReq)
	msg, err := client.Echo(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	runtime.RequestHandled(ctx, spec, "EchoService", "Echo", msg, &metadata, err)
	return msg, metadata, err

}

var (
	filter_EchoService_Echo_4 = &utilities.DoubleArray{Encoding: map[string]int{"no": 0, "note": 1}, Base: []int{1, 1, 1, 0}, Check: []int{0, 1, 2, 3}}
)

func request_EchoService_Echo_4(ctx context.Context, marshaler runtime.Marshaler, client EchoServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq SimpleMessage
	var metadata runtime.ServerMetadata
	spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec

	var (
		val string
		ok  bool
		err error
		_   = err
	)

	val, ok = pathParams["no.note"]
	if !ok {
		runtime.RequestHandled(ctx, spec, "EchoService", "Echo", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "no.note")
	}

	err = runtime.PopulateFieldFromPath(&protoReq, "no.note", val)

	if err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "no.note", err)
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_EchoService_Echo_4); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	// Only hook up for non-stream call for now.

	runtime.RequestParsed(ctx, spec, "EchoService", "Echo", &protoReq, &metadata)
	ctx = runtime.PreLoadBalance(ctx, "ROUND_ROBIN", "", &protoReq)
	msg, err := client.Echo(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	runtime.RequestHandled(ctx, spec, "EchoService", "Echo", msg, &metadata, err)
	return msg, metadata, err

}

func request_EchoService_EchoBody_0(ctx context.Context, marshaler runtime.Marshaler, client EchoServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq SimpleMessage
	var metadata runtime.ServerMetadata
	spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec

	newReader, berr := utilities.IOReaderFactory(req.Body)
	if berr != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
	}
	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
		runtime.RequestHandled(ctx, spec, "EchoService", "EchoBody", nil, &metadata, err)
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	// Only hook up for non-stream call for now.

	runtime.RequestParsed(ctx, spec, "EchoService", "EchoBody", &protoReq, &metadata)
	ctx = runtime.PreLoadBalance(ctx, "ROUND_ROBIN", "", &protoReq)
	msg, err := client.EchoBody(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	runtime.RequestHandled(ctx, spec, "EchoService", "EchoBody", msg, &metadata, err)
	return msg, metadata, err

}

var (
	filter_EchoService_EchoDelete_0 = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

func request_EchoService_EchoDelete_0(ctx context.Context, marshaler runtime.Marshaler, client EchoServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
	var protoReq SimpleMessage
	var metadata runtime.ServerMetadata
	spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec

	if err := req.ParseForm(); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_EchoService_EchoDelete_0); err != nil {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}

	// Only hook up for non-stream call for now.

	runtime.RequestParsed(ctx, spec, "EchoService", "EchoDelete", &protoReq, &metadata)
	ctx = runtime.PreLoadBalance(ctx, "ROUND_ROBIN", "", &protoReq)
	msg, err := client.EchoDelete(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	runtime.RequestHandled(ctx, spec, "EchoService", "EchoDelete", msg, &metadata, err)
	return msg, metadata, err

}

// Register itself to runtime.
func init() {
	var s *runtime.Service
	var spec *skypb.ServiceSpec

	_ = s
	_ = spec

	spec = internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec
	s = &runtime.Service{
		Spec:     *spec,
		Name:     "EchoService",
		Register: RegisterEchoServiceHandlerFromEndpoint,
		Enable:   EnableEchoService_Service,
		Disable:  DisableEchoService_Service,
	}

	runtime.AddService(s, Enable_CUSTOM_EASE_GATEWAY_TEST__default__grpc_ServiceGroup, Disable_CUSTOM_EASE_GATEWAY_TEST__default__grpc_ServiceGroup)

}

// RegisterEchoServiceHandlerFromEndpoint is same as RegisterEchoServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterEchoServiceHandlerFromEndpoint(mux *runtime.ServeMux) (err error) {
	// conn, err := grpc.Dial(endpoint, opts...)
	// if err != nil {
	// 	return err
	// }
	// defer func() {
	// 	if err != nil {
	// 		if cerr := conn.Close(); cerr != nil {
	// 			grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
	// 		}
	// 		return
	// 	}
	// 	go func() {
	// 		<-ctx.Done()
	// 		if cerr := conn.Close(); cerr != nil {
	// 			grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
	// 		}
	// 	}()
	// }()

	// return RegisterEchoServiceHandler(ctx, mux, conn)
	return RegisterEchoServiceHandler(nil, mux, nil)
}

// RegisterEchoServiceHandler registers the http handlers for service EchoService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterEchoServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterEchoServiceHandlerClient(ctx, mux, NewEchoServiceClient(conn))
}

// RegisterEchoServiceHandlerClient registers the http handlers for service EchoService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "EchoServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "EchoServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "EchoServiceClient" to call the correct interceptors.
func RegisterEchoServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client EchoServiceClient) error {
	spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec

	runtime.AddMethod(spec, "EchoService", "Echo", "/v1/example/echo/{id}", "POST", true, false, false, "UNSPECIFIED", "EASE_GATEWAY", "EASE_AUTH_TOKEN", "")
	mux.Handle("POST", pattern_EchoService_Echo_0, vexpb.ServiceId_CUSTOM_EASE_GATEWAY_TEST, func(inctx context.Context, w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		// TODO(mojz): review all locking/unlocking logic.
		// internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RLock()
		// defer internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RUnlock()
		cli := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client
		if cli == nil {
			runtime.DefaultOtherErrorHandler(w, req, "service disabled", http.StatusInternalServerError)
			return
		}

		ctx, err := runtime.RequestAccepted(inctx, internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec, "EchoService", "Echo", w, req)
		if err != nil {
			runtime.DefaultHTTPError(ctx, nil, &runtime.JSONBuiltin{}, w, req, err)
			return
		}

		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		if cn, ok := w.(http.CloseNotifier); ok {
			go func(done <-chan struct{}, closed <-chan bool) {
				select {
				case <-done:
				case <-closed:
					cancel()
				}
			}(ctx.Done(), cn.CloseNotify())
		}
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_EchoService_Echo_0(rctx, inboundMarshaler, cli, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_EchoService_Echo_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	runtime.AddMethod(spec, "EchoService", "Echo", "/v1/example/echo/{id}/{num}", "GET", true, false, false, "UNSPECIFIED", "EASE_GATEWAY", "EASE_AUTH_TOKEN", "")
	mux.Handle("GET", pattern_EchoService_Echo_1, vexpb.ServiceId_CUSTOM_EASE_GATEWAY_TEST, func(inctx context.Context, w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		// TODO(mojz): review all locking/unlocking logic.
		// internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RLock()
		// defer internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RUnlock()
		cli := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client
		if cli == nil {
			runtime.DefaultOtherErrorHandler(w, req, "service disabled", http.StatusInternalServerError)
			return
		}

		ctx, err := runtime.RequestAccepted(inctx, internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec, "EchoService", "Echo", w, req)
		if err != nil {
			runtime.DefaultHTTPError(ctx, nil, &runtime.JSONBuiltin{}, w, req, err)
			return
		}

		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		if cn, ok := w.(http.CloseNotifier); ok {
			go func(done <-chan struct{}, closed <-chan bool) {
				select {
				case <-done:
				case <-closed:
					cancel()
				}
			}(ctx.Done(), cn.CloseNotify())
		}
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_EchoService_Echo_1(rctx, inboundMarshaler, cli, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_EchoService_Echo_1(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	runtime.AddMethod(spec, "EchoService", "Echo", "/v1/example/echo/{id}/{num}/{lang}", "GET", true, false, false, "UNSPECIFIED", "EASE_GATEWAY", "EASE_AUTH_TOKEN", "")
	mux.Handle("GET", pattern_EchoService_Echo_2, vexpb.ServiceId_CUSTOM_EASE_GATEWAY_TEST, func(inctx context.Context, w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		// TODO(mojz): review all locking/unlocking logic.
		// internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RLock()
		// defer internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RUnlock()
		cli := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client
		if cli == nil {
			runtime.DefaultOtherErrorHandler(w, req, "service disabled", http.StatusInternalServerError)
			return
		}

		ctx, err := runtime.RequestAccepted(inctx, internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec, "EchoService", "Echo", w, req)
		if err != nil {
			runtime.DefaultHTTPError(ctx, nil, &runtime.JSONBuiltin{}, w, req, err)
			return
		}

		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		if cn, ok := w.(http.CloseNotifier); ok {
			go func(done <-chan struct{}, closed <-chan bool) {
				select {
				case <-done:
				case <-closed:
					cancel()
				}
			}(ctx.Done(), cn.CloseNotify())
		}
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_EchoService_Echo_2(rctx, inboundMarshaler, cli, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_EchoService_Echo_2(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	runtime.AddMethod(spec, "EchoService", "Echo", "/v1/example/echo1/{id}/{line_num}/{status.note}", "GET", true, false, false, "UNSPECIFIED", "EASE_GATEWAY", "EASE_AUTH_TOKEN", "")
	mux.Handle("GET", pattern_EchoService_Echo_3, vexpb.ServiceId_CUSTOM_EASE_GATEWAY_TEST, func(inctx context.Context, w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		// TODO(mojz): review all locking/unlocking logic.
		// internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RLock()
		// defer internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RUnlock()
		cli := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client
		if cli == nil {
			runtime.DefaultOtherErrorHandler(w, req, "service disabled", http.StatusInternalServerError)
			return
		}

		ctx, err := runtime.RequestAccepted(inctx, internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec, "EchoService", "Echo", w, req)
		if err != nil {
			runtime.DefaultHTTPError(ctx, nil, &runtime.JSONBuiltin{}, w, req, err)
			return
		}

		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		if cn, ok := w.(http.CloseNotifier); ok {
			go func(done <-chan struct{}, closed <-chan bool) {
				select {
				case <-done:
				case <-closed:
					cancel()
				}
			}(ctx.Done(), cn.CloseNotify())
		}
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_EchoService_Echo_3(rctx, inboundMarshaler, cli, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_EchoService_Echo_3(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	runtime.AddMethod(spec, "EchoService", "Echo", "/v1/example/echo2/{no.note}", "GET", true, false, false, "UNSPECIFIED", "EASE_GATEWAY", "EASE_AUTH_TOKEN", "")
	mux.Handle("GET", pattern_EchoService_Echo_4, vexpb.ServiceId_CUSTOM_EASE_GATEWAY_TEST, func(inctx context.Context, w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		// TODO(mojz): review all locking/unlocking logic.
		// internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RLock()
		// defer internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RUnlock()
		cli := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client
		if cli == nil {
			runtime.DefaultOtherErrorHandler(w, req, "service disabled", http.StatusInternalServerError)
			return
		}

		ctx, err := runtime.RequestAccepted(inctx, internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec, "EchoService", "Echo", w, req)
		if err != nil {
			runtime.DefaultHTTPError(ctx, nil, &runtime.JSONBuiltin{}, w, req, err)
			return
		}

		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		if cn, ok := w.(http.CloseNotifier); ok {
			go func(done <-chan struct{}, closed <-chan bool) {
				select {
				case <-done:
				case <-closed:
					cancel()
				}
			}(ctx.Done(), cn.CloseNotify())
		}
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_EchoService_Echo_4(rctx, inboundMarshaler, cli, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_EchoService_Echo_4(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	runtime.AddMethod(spec, "EchoService", "EchoBody", "/v1/example/echo_body", "POST", true, false, false, "UNSPECIFIED", "EASE_GATEWAY", "EASE_AUTH_TOKEN", "")
	mux.Handle("POST", pattern_EchoService_EchoBody_0, vexpb.ServiceId_CUSTOM_EASE_GATEWAY_TEST, func(inctx context.Context, w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		// TODO(mojz): review all locking/unlocking logic.
		// internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RLock()
		// defer internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RUnlock()
		cli := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client
		if cli == nil {
			runtime.DefaultOtherErrorHandler(w, req, "service disabled", http.StatusInternalServerError)
			return
		}

		ctx, err := runtime.RequestAccepted(inctx, internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec, "EchoService", "EchoBody", w, req)
		if err != nil {
			runtime.DefaultHTTPError(ctx, nil, &runtime.JSONBuiltin{}, w, req, err)
			return
		}

		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		if cn, ok := w.(http.CloseNotifier); ok {
			go func(done <-chan struct{}, closed <-chan bool) {
				select {
				case <-done:
				case <-closed:
					cancel()
				}
			}(ctx.Done(), cn.CloseNotify())
		}
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_EchoService_EchoBody_0(rctx, inboundMarshaler, cli, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_EchoService_EchoBody_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	runtime.AddMethod(spec, "EchoService", "EchoDelete", "/v1/example/echo_delete", "DELETE", true, false, false, "UNSPECIFIED", "EASE_GATEWAY", "EASE_AUTH_TOKEN", "")
	mux.Handle("DELETE", pattern_EchoService_EchoDelete_0, vexpb.ServiceId_CUSTOM_EASE_GATEWAY_TEST, func(inctx context.Context, w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
		// TODO(mojz): review all locking/unlocking logic.
		// internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RLock()
		// defer internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.RUnlock()
		cli := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client
		if cli == nil {
			runtime.DefaultOtherErrorHandler(w, req, "service disabled", http.StatusInternalServerError)
			return
		}

		ctx, err := runtime.RequestAccepted(inctx, internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec, "EchoService", "EchoDelete", w, req)
		if err != nil {
			runtime.DefaultHTTPError(ctx, nil, &runtime.JSONBuiltin{}, w, req, err)
			return
		}

		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		if cn, ok := w.(http.CloseNotifier); ok {
			go func(done <-chan struct{}, closed <-chan bool) {
				select {
				case <-done:
				case <-closed:
					cancel()
				}
			}(ctx.Done(), cn.CloseNotify())
		}
		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
		rctx, err := runtime.AnnotateContext(ctx, mux, req)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}
		resp, md, err := request_EchoService_EchoDelete_0(rctx, inboundMarshaler, cli, req, pathParams)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
			return
		}

		forward_EchoService_EchoDelete_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)

	})

	return nil
}

func Disable_CUSTOM_EASE_GATEWAY_TEST__default__grpc_ServiceGroup() {
	// internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.Lock()
	// defer internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.Unlock()
	if internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_skycli != nil {
		spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec
		sg := runtime.GetServiceGroup(spec)
		for _, svc := range sg.Services {
			svc.Disable()
		}

		internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client = nil
		internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_skycli.Shutdown()
		internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_skycli = nil
	}
}

func Enable_CUSTOM_EASE_GATEWAY_TEST__default__grpc_ServiceGroup() {
	// internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.Lock()
	// defer internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock.Unlock()

	internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_skycli = client.NewServiceCli(runtime.CallerServiceId)

	// Resolve service
	spec := internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec

	internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_skycli.Resolve(spec)

	internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_skycli.EnableResolveFullEps()
	internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_skycli.Start(func(spec *skypb.ServiceSpec, conn *grpc.ClientConn) {
		sg := runtime.GetServiceGroup(spec)
		for _, svc := range sg.Services {
			svc.Enable(spec, conn)
		}
	})
}

func EnableEchoService_Service(spec *skypb.ServiceSpec, conn *grpc.ClientConn) {
	internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client = NewEchoServiceClient(conn)
}

func DisableEchoService_Service() {
	internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client = nil
}

var (
	pattern_EchoService_Echo_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"v1", "example", "echo", "id"}, "", runtime.AssumeColonVerbOpt(true)))

	pattern_EchoService_Echo_1 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 1, 0, 4, 1, 5, 4}, []string{"v1", "example", "echo", "id", "num"}, "", runtime.AssumeColonVerbOpt(true)))

	pattern_EchoService_Echo_2 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 1, 0, 4, 1, 5, 4, 1, 0, 4, 1, 5, 5}, []string{"v1", "example", "echo", "id", "num", "lang"}, "", runtime.AssumeColonVerbOpt(true)))

	pattern_EchoService_Echo_3 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 1, 0, 4, 1, 5, 4, 1, 0, 4, 1, 5, 5}, []string{"v1", "example", "echo1", "id", "line_num", "status.note"}, "", runtime.AssumeColonVerbOpt(true)))

	pattern_EchoService_Echo_4 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"v1", "example", "echo2", "no.note"}, "", runtime.AssumeColonVerbOpt(true)))

	pattern_EchoService_EchoBody_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "example", "echo_body"}, "", runtime.AssumeColonVerbOpt(true)))

	pattern_EchoService_EchoDelete_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"v1", "example", "echo_delete"}, "", runtime.AssumeColonVerbOpt(true)))
)

var (
	forward_EchoService_Echo_0 = runtime.ForwardResponseMessage

	forward_EchoService_Echo_1 = runtime.ForwardResponseMessage

	forward_EchoService_Echo_2 = runtime.ForwardResponseMessage

	forward_EchoService_Echo_3 = runtime.ForwardResponseMessage

	forward_EchoService_Echo_4 = runtime.ForwardResponseMessage

	forward_EchoService_EchoBody_0 = runtime.ForwardResponseMessage

	forward_EchoService_EchoDelete_0 = runtime.ForwardResponseMessage
)

var (
	internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_spec   = client.NewServiceSpec("default", vexpb.ServiceId_CUSTOM_EASE_GATEWAY_TEST, "grpc")
	internal_EchoService_CUSTOM_EASE_GATEWAY_TEST_client EchoServiceClient

	internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_skycli client.ServiceCli

	internal_CUSTOM_EASE_GATEWAY_TEST__default__grpc_lock = sync.RWMutex{}
)
